/* minus.asm * Computes the Difference of variadic number of integers: R0 <- ARG[0] - ARG[1] -... */ MINUS:  PUSH(FP);  MOV(FP, SP);  PUSH(R1);  PUSH(R2);  PUSH(R3);  PUSH(R4);    MOV(R4,FPARG(1));  CMP(R4, IMM(0));  JUMP_EQ(HAS_NO_ARGS_MINUS);  CMP(R4, IMM(1));  JUMP_EQ(HAS_ONE_ARGS_MINUS);    CALL(MAKE_ARGS_FRACTIONS);  MOV(R0, INDD(FPARG(2),1));  MOV(R2, INDD(FPARG(2),2));  MOV(R1, IMM(3));  DECR(R4);    L_START_MINUS:  CMP(R4, IMM(0));  JUMP_EQ(L_FINISH_MINUS);  MUL(R0,INDD(FPARG(R1),2));  MOV(R3,INDD(FPARG(R1),1));  MUL(R3,R2);  SUB(R0,R3);  MUL(R2,INDD(FPARG(R1),2));  INCR(R1);  DECR(R4);  JUMP(L_START_MINUS);    L_FINISH_MINUS:  MOV(R3,R0);  REM(R3,R2);  CMP(R3, IMM(0));  JUMP_EQ(MAKE_INTEGER_MINUS);    PUSH(R2);  PUSH(R0);  CALL(MAKE_SOB_FRACTION);  DROP(2);  POP(R4);  POP(R3);  POP(R2);  POP(R1);  POP(FP);  RETURN;    MAKE_INTEGER_MINUS:  DIV(R0,R2);  PUSH(R0);  CALL(MAKE_SOB_INTEGER);  DROP(1);  POP(R4);  POP(R3);  POP(R2);  POP(R1);  POP(FP);  RETURN;    HAS_NO_ARGS_MINUS:  CALL(ERROR_NOT_ENOUGH_ARGS);    HAS_ONE_ARGS_MINUS:  MOV(R0,FPARG(2));  PUSH(R0);  CALL(IS_SOB_FRACTION);  DROP(1);  CMP(R0, IMM(0));  JUMP_EQ(IS_INT_MINUS);  MUL(INDD(FPARG(2),1),IMM(-1));  MOV(R0,FPARG(2));  POP(R4);  POP(R3);  POP(R2);  POP(R1);  POP(FP);  RETURN;    IS_INT_MINUS:  MUL(INDD(FPARG(2),1),IMM(-1));  MOV(R0,FPARG(2));  POP(R4);  POP(R3);  POP(R2);  POP(R1);  POP(FP);  RETURN;